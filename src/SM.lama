-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
  case i of
    READ      -> sprintf ("READ")
  | WRITE     -> sprintf ("WRITE")
  | BINOP (s) -> sprintf ("BINOP %s", s)
  | LD    (x) -> sprintf ("LD %s", x)
  | ST    (x) -> sprintf ("ST %s", x)
  | CONST (n) -> sprintf ("CONST %d", n)
  esac
}

public fun showSM (prg) {
  map (fun (i) {showSMInsn (i) ++ "\n"}, prg).stringcat
}

fun evalInsn (c@[stck, stt, wrld], i) {
    case i of
      READ -> case readWorld (wrld) of [n, newWrld] -> [n:stck, stt, newWrld] esac
    | WRITE -> case stck of (s:ss) -> [ss, stt, writeWorld (s, wrld)] esac
    | BINOP (op) -> case stck of (s:f:ss) -> [evalOp (op, f, s) : ss, stt, wrld] esac
    | LD (x) -> [stt (x) : stck, stt, wrld]
    | ST (x) -> case stck of (s:ss) -> [ss, stt <- [x, s], wrld] esac
    | CONST (n) -> [n : stck, stt, wrld]
    esac
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c@[stck, stt, wrld], insns) {
    case insns of
      {} -> c
    | i : is -> eval (evalInsn (c, i), is)
    esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr (expr) {
    case expr of
      Var(varName) -> { LD (varName) }
    | Const(x) -> { CONST (x) }
    | Binop (op, le, re) -> compileExpr(le) +++ compileExpr(re) +++ { BINOP (op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
    case stmt of 
      Assn (s, e)  -> compileExpr (e) +++ { ST (s) } 
    | Seq (lsm, rsm) -> compileSM (lsm) +++ compileSM (rsm)
    | Skip -> {}
    | Read (s) -> { READ } +++ { ST (s) }  
    | Write (e) -> compileExpr (e) +++ { WRITE }
    esac
}