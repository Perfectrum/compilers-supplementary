-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr ({
			  [ Left, pBinop . map ({ "&&", "!!" }) ]
			, [ Nona, pBinop . map ({ ">", "<", ">=", "<=", "==", "!=" }) ]
			, [ Left, pBinop . map ({ "+", "-" }) ]
			, [ Left, pBinop . map ({ "*", "/", "%" }) ]
     }, primary));

fun pBinop (op) {[ s (op), fun (l, op, r) { Binop (op, l, r) } ]}

var stmt = memo $ eta expr (
    {[ Left, {[ s (";"), fun (l, op, r) { Seq (l, r) } ]} ]},
    syntax (
        kSkip 				{ Skip }        |
        n = lident s [":="] e = exp     { Assn (n, e) } |
        kRead s ["("] n = lident s[")"] { Read (n) }    |
        kWrite s ["("] e=exp s[")"]     { Write (e) }
    )
);

-- Public top-level parser
public parse = stmt;
             
