-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr ({
			  [ Left, pBinop . map ({ "&&", "!!" }) ]
			, [ Nona, pBinop . map ({ ">", "<", ">=", "<=", "==", "!=" }) ]
			, [ Left, pBinop . map ({ "+", "-" }) ]
			, [ Left, pBinop . map ({ "*", "/", "%" }) ]
     }, primary));

fun pBinop (op) {[ s (op), fun (l, op, r) { Binop (op, l, r) } ]}

var stmt = memo $ eta expr (
    {[ Left, {[ s (";"), fun (l, op, r) { Seq (l, r) } ]} ]},
    memo $ eta syntax (
        kSkip 				                            { Skip }                |
        n = lident s [":="] e = exp                     { Assn (n, e) }         |
        kRead s ["("] n = lident s [")"]                { Read (n) }            |
        kWrite s ["("] e=exp s [")"]                    { Write (e) }           |        
        kIf cnd=exp kThen thn=stmt kFi                  { If (cnd, thn, Skip) } |
        kIf cnd=exp kThen thn=stmt els=ifTail kFi       { If (cnd, thn, els) }  |
        kWhile cnd=exp kDo wrk=stmt kOd                 { While (cnd, wrk) }    |
        kDo wrk=stmt kWhile cnd=exp kOd                 { DoWhile (wrk, cnd) }  |
        kFor init=stmt s[","] cnd=exp s[","] inc=stmt kDo wrk=stmt kOd
                                  { Seq (init, While (cnd, Seq (wrk, inc))) } 
    )
),
  ifTail = memo $ syntax (
    kElif cnd=exp kThen thn=stmt els=ifTail { If (cnd, thn, els) } |
    kElse els=stmt                          { els }                
);

-- Public top-level parser
public parse = stmt;
